#!/usr/bin/env bash
set -euo pipefail

# Conventional Commit validator for commit-msg.
# Git passes:
#   $1: path to commit message file

MSG_FILE="${1:-}"
if [[ -z "$MSG_FILE" || ! -f "$MSG_FILE" ]]; then
  exit 0
fi

log() {
  # Keep output visible in git/lefthook while being clearly attributable.
  echo "conventional_validate: $*" >&2
}

log "checking message file: $MSG_FILE"

# Read first non-comment line.
first_line="$(grep -v '^[[:space:]]*#' "$MSG_FILE" | head -n 1 || true)"
first_line="${first_line//$'\r'/}"
log "first non-comment line: ${first_line:-<empty>}"

# Allow empty (Git will usually block anyway) and special cases.
if [[ -z "${first_line:-}" ]]; then
  log "✗ empty commit message"
  exit 1
fi

# Allow merge commits and reverts generated by git tooling.
if [[ "$first_line" =~ ^Merge\  ]]; then
  log "merge commit detected; skipping conventional commit validation"
  exit 0
fi
if [[ "$first_line" =~ ^Revert\  ]]; then
  log "revert commit detected; skipping conventional commit validation"
  exit 0
fi

types="feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert"

# Conventional Commits header:
#   type(scope)!: subject
# where scope and ! are optional.
#
# We require:
# - type is one of the allowed set
# - optional scope in parens with no spaces
# - optional ! for breaking change
# - colon + space
# - non-empty subject
pattern="^(${types})(\\([^)[:space:]]+\\))?(!)?:[[:space:]]+.+$"

if ! [[ "$first_line" =~ $pattern ]]; then
  log "✗ does not match conventional commits pattern: $pattern"
  cat >&2 <<'EOF'
✗ Commit message must follow Conventional Commits.

Expected:
  type(scope)!: subject

Examples:
  feat(ui): add theme picker
  fix(api)!: change playlist format
  chore: bump deps

Allowed types:
  feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert
EOF
  echo >&2
  log "got: $first_line"
  exit 1
fi

log "✓ valid conventional commit"


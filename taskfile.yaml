version: 3

silent: true

tasks:
  format:prettier:
    desc: 'Format supported files with Prettier (requires global prettier)'
    dir: .
    cmds:
      - |
        if ! command -v prettier >/dev/null 2>&1; then
          echo "‚úó prettier is not available (expected global install)"
          echo "  install with: npm i -g prettier"
          exit 1
        fi
        prettier --write --ignore-unknown .
  ui:lint:
    desc: 'Run ESLint for the UI project (no auto-fix)'
    dir: projects/ui
    cmd: npm run -s lint
  ui:dev:
    desc: 'Run the UI development stack'
    summary: 'Runs the react dev server. Also processes songs (will not re-process any songs that have already been processed), generates the config, and concatenates the audio playlist.'
    dir: projects/ui
    cmds:
      - task: api:process_songs
      - task: api:generate_config
      - task: api:concatenate_playlist
      - npm run dev
  ui:build:
    desc: 'Build the UI for production'
    summary: 'Builds the UI (& only the UI) for production using Vite.'
    dir: projects/ui
    cmd: npm run build
  ui:preview:
    desc: 'Preview the UI for production'
    summary: 'Previews a production build of the UI (IE no source maps, no dev server - just the built files).'
    dir: projects/ui
    cmd: npm run preview
  ui:deploy:
    desc: 'Deploy the UI to S3'
    summary: 'Deploys the UI to S3. Also processes songs (will not re-process any songs that have already been processed), generates the config, concatenates the audio playlist, and generates the favicon.'
    dir: .
    cmd: scripts/tasks/ui_deploy.sh "${VERSION:-v1}"
  env:init:
    desc: 'Initialize the environment variables'
    summary: 'Initializes the environment variables from the .env file.'
    dir: .
    cmd: |
      set -a; source .env; set +a
  infra:init:
    desc: 'Initialize the Terraform infrastructure'
    summary: 'Initializes the Terraform infrastructure. Also initializes the environment variables.'
    dir: projects/infra
    cmds:
      - task: env:init
      - |
        terraform init -reconfigure \
          -backend-config="bucket=$TF_STATE_BUCKET" \
          -backend-config="key=$TF_STATE_KEY" \
          -backend-config="region=$TF_STATE_REGION" \
          -backend-config="dynamodb_table=$TF_STATE_DYNAMODB_TABLE" \
          -backend-config="encrypt=true"
  infra:plan:
    desc: 'Plan the Terraform infrastructure'
    dir: projects/infra
    cmd: terraform plan
  infra:apply:
    desc: 'Apply the Terraform infrastructure'
    dir: projects/infra
    cmd: terraform apply
  infra:fmt:
    desc: 'Check Terraform formatting (terraform fmt -check)'
    dir: projects/infra
    cmd: terraform fmt -check -diff -recursive
  infra:tflint:
    desc: 'Run tflint on Terraform files'
    dir: projects/infra
    cmd: tflint --recursive
  infra:lint:
    desc: 'Run Terraform formatting + lint checks'
    cmds:
      - task: infra:fmt
      - task: infra:tflint
  infra:destroy:
    desc: 'Destroy the Terraform infrastructure'
    dir: projects/infra
    cmd: terraform destroy
  infra:ssl_status:
    desc: 'Check SSL certificate validation status'
    dir: projects/infra
    cmd: terraform output certificate_validation_status
  infra:ssl_info:
    desc: 'Display SSL certificate information'
    dir: projects/infra
    cmd: |
      echo "SSL Certificate Information:"
      echo "Domain: $(terraform output -raw certificate_domain_name)"
      echo "ARN: $(terraform output -raw certificate_arn)"
      echo "Status: $(terraform output -raw certificate_validation_status)"
      echo ""
      echo "Website URLs:"
      echo "Custom Domain: $(terraform output -raw website_url)"
      echo "CloudFront URL: $(terraform output -raw cloudfront_url)"
  infra:outputs:
    desc: 'View all Terraform outputs'
    dir: projects/infra
    cmd: terraform output
  infra:invalidate:
    desc: 'Invalidate CloudFront cache manually'
    summary: 'Invalidates the CloudFront cache for all paths. This is also done automatically by task ui:deploy.'
    dir: projects/infra
    cmds:
      - |
        if ! command -v aws >/dev/null 2>&1; then
          echo "‚ùå AWS CLI is not installed"
          echo "  Install with: https://aws.amazon.com/cli/"
          exit 1
        fi
      - |
        DISTRIBUTION_ID=$(terraform output -raw cloudfront_distribution_id)
        if [ -z "$DISTRIBUTION_ID" ]; then
          echo "‚ùå Error: Could not get CloudFront distribution ID from Terraform outputs"
          echo "Make sure you've run 'task infra:apply' first"
          exit 1
        fi
        echo "üîÑ Invalidating CloudFront cache..."
        aws cloudfront create-invalidation --distribution-id "$DISTRIBUTION_ID" --paths "/*"
        if [ $? -eq 0 ]; then
          echo "‚úÖ CloudFront invalidation successful!"
        else
          echo "‚ùå CloudFront invalidation failed"
          exit 1
        fi
  api:lint:
    desc: 'Lint all Lambda functions and scripts with ruff'
    dir: projects/api
    cmds:
      - task: api:install
      - |
        echo "üîç Linting Lambda functions..."
        for lambda_dir in */; do
          if [ -f "$lambda_dir"/*.py ] && [ -f "$lambda_dir/pyproject.toml" ]; then
            echo "  Linting $lambda_dir"
            uv run ruff check "$lambda_dir"/*.py 2>/dev/null || true
          fi
        done
        echo "üîç Linting scripts..."
        uv run ruff check scripts/ 2>/dev/null || true
  api:lint:lambda:
    desc: 'Lint a specific Lambda function with ruff (usage: task api:lint:lambda LAMBDA_NAME)'
    dir: projects/api
    cmds:
      - task: api:install
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "‚ùå Error: Please specify Lambda name"
          echo "Usage: task api:lint:lambda config-post"
          exit 1
        fi
        LAMBDA_NAME={{.CLI_ARGS}}
        if [ ! -d "$LAMBDA_NAME" ] || [ ! -f "$LAMBDA_NAME/pyproject.toml" ]; then
          echo "‚ùå Error: Lambda '$LAMBDA_NAME' not found or missing pyproject.toml"
          exit 1
        fi
        echo "üîç Linting $LAMBDA_NAME..."
        uv run ruff check "$LAMBDA_NAME"/*.py
  api:isort:
    desc: 'Sort imports (isort) for all Lambda functions and scripts'
    dir: projects/api
    cmds:
      - task: api:install
      - |
        echo "üìù Sorting imports in Lambda functions..."
        for lambda_dir in */; do
          if [ -f "$lambda_dir"/*.py ] && [ -f "$lambda_dir/pyproject.toml" ]; then
            echo "  Sorting $lambda_dir"
            uv run isort "$lambda_dir"/*.py 2>/dev/null || true
          fi
        done
        echo "üìù Sorting imports in scripts..."
        uv run isort scripts/*.py
  api:format:
    desc: 'Format all Lambda functions and scripts with black'
    dir: projects/api
    cmds:
      - task: api:install
      - |
        echo "üé® Formatting Lambda functions..."
        for lambda_dir in */; do
          if [ -f "$lambda_dir"/*.py ] && [ -f "$lambda_dir/pyproject.toml" ]; then
            echo "  Formatting $lambda_dir"
            uv run black "$lambda_dir"/*.py 2>/dev/null || true
          fi
        done
        echo "üé® Formatting scripts..."
        uv run black scripts/*.py
  api:types:
    desc: 'Run mypy type checking on all Lambda functions and scripts'
    dir: projects/api
    cmds:
      - task: api:install
      - |
        echo "üîç Type checking Lambda functions..."
        for lambda_dir in */; do
          if [ -f "$lambda_dir"/*.py ] && [ -f "$lambda_dir/pyproject.toml" ]; then
            echo "  Checking $lambda_dir"
            uv run mypy "$lambda_dir"/*.py 2>/dev/null || true
          fi
        done
        echo "üîç Type checking scripts..."
        uv run mypy scripts/*.py 2>/dev/null || true
  api:install:
    desc: 'Install all dependencies (dev + runtime) using uv'
    dir: projects/api
    cmds:
      - |
        if ! command -v uv >/dev/null 2>&1; then
          echo "‚ùå uv is not installed"
          echo "  Install with: curl -LsSf https://astral.sh/uv/install.sh | sh"
          echo "  Or: pip install uv"
          exit 1
        fi
        echo "üì¶ Installing dependencies with uv..."
        uv sync
        echo "‚úÖ Dependencies installed"
  api:sync_deps:
    desc: 'Show runtime dependencies from Lambda pyproject.toml files (uv workspaces handle this automatically)'
    dir: projects/api
    cmds:
      - |
        echo "üìã Lambda runtime dependencies (automatically managed by uv workspace):"
        echo ""
        for lambda_dir in */; do
          if [ -f "$lambda_dir/pyproject.toml" ]; then
            echo "  $lambda_dir:"
            grep -A 10 "^dependencies = \[" "$lambda_dir/pyproject.toml" | grep -v "^dependencies" | sed 's/^/    /' || echo "    (no runtime deps)"
          fi
        done
        echo ""
        echo "‚úÖ uv workspace automatically installs all Lambda dependencies!"
  api:python_path:
    desc: 'Show the Python executable path for the uv workspace'
    dir: projects/api
    cmds:
      - |
        if ! command -v uv >/dev/null 2>&1; then
          echo "‚ùå uv is not installed"
          exit 1
        fi
        PYTHON_PATH=$(uv python find 2>/dev/null)
        if [ -z "$PYTHON_PATH" ]; then
          echo "‚ùå uv virtual environment not found"
          echo "  Run 'task api:install' first to create the environment"
          exit 1
        fi
        echo "$PYTHON_PATH"
  api:list:
    desc: 'List all installed packages in the uv workspace'
    dir: projects/api
    cmds:
      - |
        if ! command -v uv >/dev/null 2>&1; then
          echo "‚ùå uv is not installed"
          exit 1
        fi
        uv pip list
  api:package:config-post:
    desc: 'Package the config-post Lambda function into a deployment zip using Docker'
    dir: .
    cmd: scripts/tasks/lambda_package.sh config-post "${DOCKER_PLATFORM:-linux/amd64}"
  api:deploy:config-post:
    desc: 'Deploy the config-post Lambda function to AWS'
    dir: .
    cmd: scripts/tasks/lambda_deploy.sh config-post "${PROJECT:-lit-up}" "${ENVIRONMENT:-dev}" "${AWS_REGION:-us-east-1}"
  api:package:config-get:
    desc: 'Package the config-get Lambda function into a deployment zip using Docker'
    dir: .
    cmd: scripts/tasks/lambda_package.sh config-get "${DOCKER_PLATFORM:-linux/amd64}"
  api:deploy:config-get:
    desc: 'Deploy the config-get Lambda function to AWS'
    dir: .
    cmd: scripts/tasks/lambda_deploy.sh config-get "${PROJECT:-lit-up}" "${ENVIRONMENT:-dev}" "${AWS_REGION:-us-east-1}"
  api:package:config-delete:
    desc: 'Package the config-delete Lambda function into a deployment zip using Docker'
    dir: .
    cmd: scripts/tasks/lambda_package.sh config-delete "${DOCKER_PLATFORM:-linux/amd64}"
  api:deploy:config-delete:
    desc: 'Deploy the config-delete Lambda function to AWS'
    dir: .
    cmd: scripts/tasks/lambda_deploy.sh config-delete "${PROJECT:-lit-up}" "${ENVIRONMENT:-dev}" "${AWS_REGION:-us-east-1}"
  api:package:config-list:
    desc: 'Package the config-list Lambda function into a deployment zip using Docker'
    dir: .
    cmd: scripts/tasks/lambda_package.sh config-list "${DOCKER_PLATFORM:-linux/amd64}"
  api:deploy:config-list:
    desc: 'Deploy the config-list Lambda function to AWS'
    dir: .
    cmd: scripts/tasks/lambda_deploy.sh config-list "${PROJECT:-lit-up}" "${ENVIRONMENT:-dev}" "${AWS_REGION:-us-east-1}"
  api:package:config-patch:
    desc: 'Package the config-patch Lambda function into a deployment zip using Docker'
    dir: .
    cmd: scripts/tasks/lambda_package.sh config-patch "${DOCKER_PLATFORM:-linux/amd64}"
  api:deploy:config-patch:
    desc: 'Deploy the config-patch Lambda function to AWS'
    dir: .
    cmd: scripts/tasks/lambda_deploy.sh config-patch "${PROJECT:-lit-up}" "${ENVIRONMENT:-dev}" "${AWS_REGION:-us-east-1}"
  api:deploy:
    desc: 'Package and deploy all API lambdas (config-post/get/delete/list/patch)'
    dir: .
    cmds:
      - task: api:package:config-post
      - task: api:deploy:config-post
      - task: api:package:config-get
      - task: api:deploy:config-get
      - task: api:package:config-delete
      - task: api:deploy:config-delete
      - task: api:package:config-list
      - task: api:deploy:config-list
      - task: api:package:config-patch
      - task: api:deploy:config-patch
  api:e2e:
    desc: 'Run API E2E tests against local Flask server (default) or deployed API Gateway'
    summary: 'Runs pytest E2E tests. Set API_BASE_URL env var to test against deployed API Gateway (e.g., API_BASE_URL=https://api.example.com/dev task api:test). Set API_KEY env var if testing deployed API Gateway. For local testing, ensure Flask server is running via "task up".'
    dir: projects/api
    cmds:
      - |
        if ! command -v uv >/dev/null 2>&1; then
          echo "‚ùå uv is not installed"
          exit 1
        fi
        echo "üß™ Running API E2E tests..."
        API_URL="${API_BASE_URL:-http://127.0.0.1:3000}"
        echo "   API_BASE_URL=${API_URL}"
        echo "   API_KEY=${API_KEY:+set (hidden)}"
        if [ "${API_URL}" = "http://127.0.0.1:3000" ]; then
          echo ""
          echo "‚ö†Ô∏è  Note: Testing against local Flask server."
          echo "   Make sure the server is running: task up"
        fi
        uv run pytest tests/ -v
  api:e2e:local:
    desc: 'Run API E2E tests against local Flask server (explicit)'
    dir: projects/api
    cmds:
      - |
        API_BASE_URL=http://127.0.0.1:3000 task api:e2e
  api:e2e:deployed:
    desc: 'Run API E2E tests against deployed API Gateway (requires API_BASE_URL and API_KEY env vars)'
    dir: projects/api
    cmds:
      - |
        if [ -z "${API_BASE_URL:-}" ]; then
          echo "‚ùå API_BASE_URL environment variable is required"
          echo "   Example: API_BASE_URL=https://api.example.com/dev API_KEY=xxx task api:test:deployed"
          exit 1
        fi
        if [ -z "${API_KEY:-}" ]; then
          echo "‚ùå API_KEY environment variable is required"
          echo "   Example: API_BASE_URL=https://api.example.com/dev API_KEY=xxx task api:test:deployed"
          exit 1
        fi
        task api:e2e
  up:
    desc: 'Start local development stack (UI + API + DynamoDB)'
    summary: 'Starts the full local development environment via docker compose: UI dev server, SAM API Gateway/Lambda emulation, DynamoDB Local, and DynamoDB Admin UI.'
    dir: .
    cmds:
      - |
        if ! command -v docker >/dev/null 2>&1; then
          echo "‚ùå docker is not installed"
          exit 1
        fi
        docker compose -f docker-compose.local.yml up --build
  down:
    desc: 'Stop local development stack'
    summary: 'Stops all local development services (UI, API, DynamoDB) running in docker compose.'
    dir: .
    cmds:
      - |
        if ! command -v docker >/dev/null 2>&1; then
          echo "‚ùå docker is not installed"
          exit 1
        fi
        docker compose -f docker-compose.local.yml down
  api:ensure_venv:
    desc: 'Ensure the Python virtual environment is setup (legacy - for scripts/)'
    dir: projects/api/scripts
    cmds:
      - |
        echo "üêç Setting up Python virtual environment..."
        if [ ! -d "venv" ]; then
          python -m venv venv
          echo "‚úÖ Virtual environment created"
        fi
  api:process_songs:
    desc: 'Process the songs'
    summary: 'Processes the songs using the process_songs.py script. Also analyzes the songs and updates the lit_up_config.yaml with the actual durations.'
    dir: projects/api/scripts
    cmds:
      - task: api:ensure_venv
      - |
        source venv/bin/activate
        echo "üì¶ Installing requirements..."
        pip install -r requirements.txt
        echo "üöÄ Running process_songs.py..."
        python process_songs.py --config ../../../lit_up_config.yaml --out-dir ../../ui/.out
      - task: api:analyze_song_durations
  api:analyze_song_durations:
    desc: 'Analyze song durations'
    summary: 'Analyzes the songs and updates the lit_up_config.yaml with the actual durations.'
    dir: projects/api/scripts
    cmds:
      - task: api:ensure_venv
      - |
        echo "üîç Analyzing MP3 durations..."
        source venv/bin/activate
        pip install -r requirements.txt -q
        python analyze_song_durations.py --config ../../../lit_up_config.yaml --out-dir ../../ui/.out
  api:generate_config:
    desc: 'Convert lit_up_config.yaml to appConfig.json for the app'
    dir: projects/api/scripts
    cmds:
      - |
        echo "üîÑ Converting YAML to JSON..."
        source venv/bin/activate
        pip install -r requirements.txt -q
        python generate_config.py --config ../../../lit_up_config.yaml --out-dir ../../ui/.out
  api:concatenate_playlist:
    desc: 'Create concatenated audio playlist for iOS lock screen compatibility'
    dir: projects/api/scripts
    cmds:
      - task: api:ensure_venv
      - |
        echo "üéµ Creating concatenated audio playlist..."
        source venv/bin/activate
        pip install -r requirements.txt -q
        python concatenate_playlist.py --out-dir ../../ui/.out
  api:generate_favicon:
    desc: 'Generate favicon SVG and PNG from emoji in lit_up_config.yaml'
    dir: projects/api/scripts
    cmds:
      - task: api:ensure_venv
      - |
        echo "üé® Generating favicon..."
        source venv/bin/activate
        pip install -r requirements.txt -q
        # this is a hack to get the favicon into the ui directory
        # once we have a proper API, we can remove this
        python emoji_to_favicon.py --config ../../../lit_up_config.yaml -f svg -o ../../ui/.out/favicon.svg
        python emoji_to_favicon.py --config ../../../lit_up_config.yaml -f png -o ../../ui/.out/favicon-32x32.png -s 32
        echo "‚úÖ Favicon generated!"
